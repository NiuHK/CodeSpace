---
title: "计算机组成原理笔记 Chapter 4"
toc: true
top: 0
date: 2024-04-01 13:34:05
tags: [计算机组成原理,笔记]
---

> 计算机组成原理笔记
> Chapter 4

<!-- more -->

## 指令格式设计

### 基本结构

1. 操作码
2. 源操作数/其地址or立即数：储存单元地址/寄存器编号/io端口
3. 结果的地址：储存单元地址/寄存器编号/io端口
4. 下条地址：通常隐含在PC中（按顺序执行时，下条地址为PC+地址长度）转移指令则跳转到给出的地址。

> 根据给出的地址个数，分为三、二、单、零地址指令
>
> 1. 三：双目运算符两个源操作数地址和一个结果地址
> 2. 二：双目运算符两个源操作数，其中一个作为结果地址
> 3. 一：（取反/负）既是操作数地址也是结果地址
> 4. 零地址：一种是无需，or栈型指令的操作数在栈顶，故不需要

### 指令格式设计原则

1. 指令尽量短
2. 足够操作码位数
3. 指令长度是字节的整数倍
4. 合理选择地址字段个数
5. 指令应尽量规整

## 指令系统设计

1. 完备性完整性（指令的操作类型）
2. 兼容性（兼容以前机器的指令）
3. 均匀性（多种数据类型eg：三种整型，两种浮点）
4. 可扩充性（预留一定编码空间，方便扩充）

### 基本设计问题

### 操作数类型

1. 指针以及地址
2. 数值数据
3. 位、位串、字符以及字符串

### *寻址方式

> 注意，一条指令若有两个或两个以上的地址码时，各地址码可采用不同的寻址方式。例如，源地址采用一种寻址方式，而目的地址采用另一种寻址方式。

1. 立即寻址：指令直接给出操作数本身
2. 直接寻址：指令中给出操作数的有效地址（直接/绝对地址）
3. 间接寻址：给出操作数的地址的地址（可多重）![1711967468630](1711967468630.png)
4. 寄存器寻址：地址码是操作数所在寄存器编号

   > 1. 寄存器地址断，故寄存器寻址指令短
   > 2. 操作数已经在cpu，不访存，速度快
   >
5. 寄存器间接寻址：寄存器中存放操作数的有效地址，需要访存![1711967453239](1711967453239.png)
6. 变址寻址：线性表等，给出基准地址，（变址寄存器 I ）给出偏移量![1711967507150](1711967507150.png)

   > 把变址寄存器Rx的内容与指令中给出的形式地址A相加，形成操作数有效地址，即EA=(Rx)+A。Rx的内容称为变址值。
   > S=((Rx)+A)
   >
7. 相对寻址：相对寻址是基址寻址的一种变通，由程序计数器PC提供基准地址，指令中的地址码字段作为位移量D，两者相加后得到操作数的有效地址，即 `EA=(PC)+D`。位移量指出的是操作数和现行指令之间的相对位置。

> 相对寻址方式的特点：
>
> 1. 操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值±D。当指令地址改变时，由于其位移量不变，使得操作数与指令在可用的存储区内一起移动，所以仍能保证程序的正确执行。采用PC相对寻址方式编写的程序可在主存中任意浮动，它放在主存的任何地方，所执行的效果都是一样的。
> 2. 由于指令中给出的位移量可正、可负，所以对于指令地址而言，操作数地址可能在指令地址之前或之后。

![1711967634860](1711967634860.png)
8. 基址寻址：基址寄存器Rb的内容与指令中给出的位移量D相加，形成操作数有效地址，即EA=(Rb)+D。基址寄存器的内容称为基址值。指令的地址码字段是一个位移量，位移量可正、可负。

> S=((Rb)+D)

![1711967678881](1711967678881.png)

#### Conclution

寻址方式指如何在指令中表示要访问的内存地址。表2.4列出了计算机中常用的寻址方式，其中数组mem表示存储器，数组regs表示寄存器，mem[regs[Rn]]表示由寄存器Rn的值作为存储器地址所访问的存储器值。

表 2.4: 常用寻址方式

| **寻址方式**                       | **格式**               | **含义**                                                |
| ---------------------------------------- | ---------------------------- | ------------------------------------------------------------- |
| **寄存器寻址（Register）**         | **ADD R1,R2**          | **regs[R1]=regs[R1]+regs[R2]**                          |
| **立即数寻址（Immediate）**        | **ADD R1,#2**          | **regs[R1]=regs[R1]+2**                                 |
| **偏移量寻址（Displacement）**     | **ADD R1,100(R2)**     | **regs[R1]=regs[R1]+mem[100+regs[R2]]**                 |
| **寄存器间接寻址（Reg.Indirect）** | **ADD R1,(R2)**        | **regs[R1]=regs[R1]+mem[regs[R2]]**                     |
| **变址寻址（Indexed）**            | **ADD R1,(R2+R3)**     | **regs[R1]=regs[R1]+mem[regs[R2]+regs[R3]]**            |
| **绝对寻址（Absolute）**           | **ADD R1,(100)**       | **regs[R1]=regs[R1]+mem[100]**                          |
| **存储器间接寻址（Mem.Indirect）** | **ADD R1,@(R2)**       | **regs[R1]=regs[R1]+mem[mem[regs[R2]]]**                |
| **自增量寻址（Autoincrement）**    | **ADD R1,(R2)+**       | **regs[R1]=regs[R1]+mem[regs[R2]],regs[R2]=regs[R2]+d** |
| **自减量寻址（Autodecrement）**    | **ADD R1,-(R2)**       | **regs[R2]=regs[R2]-d,regs[R1]=regs[R1]+mem[regs[R2]]** |
| **比例变址寻址（Scaled）**         | **ADD R1,100(R2)(R3)** | **regs[R1]=regs[R1]+mem[100+regs[R2]+regs[R3]*d]**        |

### 操作类型

1. 算数和逻辑运算指令：加减乘除/比较/加一减一/位运算
2. 移位指令
3. 传送指令
4. 串指令
5. 顺序控制指令：转移、跳转、跳步、调用、返回
6. CPU控制指令
7. 输入输出指令

### 操作码编码

1. 定长操作码编码：

> 长度固定，译码方便，执行指令速度快，但有信息冗余。

1. 扩展操作码编码：

> 几种固定长度的格式，4-8-12，3-6-9等，多用于非规整性指令集

### 异常以及中断处理

#### 异常 exception：

也称为例外，执行时cpu内部发生的。

1. 故障：遇到终止程序执行。
2. 自陷：人为埋设，例如断点、单步追踪，处理结束返回下条继续执行。
3. 终止：特殊事件，每条指令执行完都检查有无中断指令，有则将 `下条指令`作为断点保存，并转到相应断点服务执行，结束后返回断点继续。
   > 终止与指令执行无关，由CPU外部的I/O部件通过专门的中断请求线向CPU请求
   >

## 程序的机器级表示

略
